# hwJavaOop6

## Выявленные нарушения SOLID:
1. Open/Closed Principle, так как в Persister метод save "прибит гвозядми", т.е. его логика привязана к классу User (в метое save), 
получается, что для сохранения иных объектов необходимо создание ещё одного метода или изменение старого, что нарушает OCP.
2. Dependency Inversion Principle, не соблюдается, так как класс User зависит от класса Persister, что должно быть наоборот. 
К тому же не ясно каким образом объекты будут сохранятся.
3. Принцип SRP тоже как будто бы нарушен, т.к. в классе User находятся две функции - report и save, но с правильной реализацией первых двух принципов
он нивелируется!

## Решение:
1. Изменение класса Persister на интерфейс Persister, но, как и раньше, он отвечает за сохранение объекта User
2. Добавление класса TxtFileUserSaver имплементирующего Persister. Теперь логика сохранение "new User" может происходить 
по любой логике и способом описанным в новом классе, что положительно влияет на маштабируемость, т.к. можно просто создать другую реализацию Persister
3. Изменения в классе Main, где создаётся эксемпляр класса "TxtFileUserSaver", теперь помогают сохранить нового User в том виде, в котором этого хочет пользователь

## Вывод:
1. SRP не нарушается, так как класс User теперь отвечает только за свою собственную функциональность,
интерфейс Persister отвечает только за сохранение пользователей, а класс TxtFileUserSaver реализует сохранение пользователей в файл.
2. OCP не нарушается, так как мы можем легко добавлять новые реализации интерфейса Persister.
3. Так же соблюдается DIP, потому как класс User зависит от самого интерфейса Persister(т.е. абстракции), а не от конкретной его реализации.
